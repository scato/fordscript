module generate

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/FordScript
  lib/editor-common.generated

rules

  to-jsfax = innermost(desugar)
  
  desugar:
    FSBlock(s*) -> s*
  
  desugar:
    FSLambdaExp(x*, exp) -> JSFunctionExp(x*, [JSReturn(exp)])
  
  desugar:
    FSTypedLambdaExp(x*, t, exp) -> FSLambdaExp(x*, exp)
  
  desugar:
    FSTypedIdentifier(i, t) -> FSIdentifier(i)
  
  desugar:
    FSTypedFunctionDecl(i, x*, t, s*) -> JSFunctionDecl(i, x*, s*)
  
  desugar:
    FSTypedFunctionExp(x*, t, s*) -> JSFunctionExp(x*, s*)

  member-to-constructor(|c):
    JSFunctionDecl("constructor", x*, s*) -> JSFunctionDecl(c, x*, s*)
    
  class-to-constructor(|c):
    s* -> constructor
    with
      if <getfirst(member-to-constructor(|c))> s* then
        constructor := <getfirst(member-to-constructor(|c))> s*
      else
        constructor := JSFunctionDecl(c, [], [])
      end
  
  super-call-to-apply(|c):
    FSSuperCall(i, x*) -> [
      $[ [c].prototype.[i].apply(this, ["["] ],
      xs,
      $[ ["]"]) ]
    ]
    with
      xs := <separate-by(|", ")> x*
  
  desugar:
    FSClassDecl(c, s*) -> [
      <class-to-constructor(|c)> s'*,
      <map(try(class-to-prototype(|c)))> s'*
    ]
    with
      s'* := <map(bottomup(try(super-call-to-apply(|"Object"))))> s*
  
  desugar:
    FSExtendedClassDecl(c, FSType(e), s*) -> [
      <class-to-constructor(|c)> s'*,
      $[ [c].prototype = function() { var c = function() {}; c.prototype = [e].prototype; var p = new c(); p.constructor = c; return p; }(); ],
      <map(try(class-to-prototype(|c)))> s'*
    ]
    with
      s'* := <map(bottomup(try(super-call-to-apply(|e))))> s*
  
  desugar:
    FSClassAugmentation(c, s*) ->
      <map(try(class-to-prototype(|c)))> s*
  
  class-to-prototype(|c):
    s* -> <map(class-to-prototype(|c))> s*
  
  class-to-prototype(|c):
    JSVarDecl(FSIdentifier(p), v) ->
      JSExpStat(JSAssign(FSIdentifier(JSLFieldAccess(JSLFieldAccess(c,"prototype"), p)), "=", v))
  
  class-to-prototype(|c):
    JSVarDeclNoInit(i) -> []
  
  class-to-prototype(|c):
    JSFunctionDecl(p, x*, s*) ->
      result
    with
      if(<eq> (p, "constructor")) then
        result := []
      else
        result := JSExpStat(JSAssign(FSIdentifier(JSLFieldAccess(JSLFieldAccess(c,"prototype"), p)), "=", JSFunctionExp(x*, s*)))
      end

  static-to-prototype(|c):
    JSVarDecl(FSIdentifier(p), v) ->
      JSExpStat(JSAssign(FSIdentifier(JSLFieldAccess(c, p)), "=", v))
  
  static-to-prototype(|c):
    JSVarDeclNoInit(i) -> []
  
  class-to-prototype(|c):
    FSStaticDecl(JSFunctionDecl(p, x*, s*)) ->
      JSExpStat(JSAssign(FSIdentifier(JSLFieldAccess(c, p)), "=", JSFunctionExp(x*, s*)))

  class-to-prototype(|c):
    FSStaticDecl(s*) -> result
    with
      result := <map(static-to-prototype(|c))> s*
  
  desugar:
    FSPrototypeDecl(p, s*) -> [
      $[ var [p] = {}; ],
      <map(try(prototype-to-prototype(|p)))> s*
    ]

  desugar:
    FSExtendedPrototypeDecl(p, FSType(e), s*) -> [
      $[ var [p] = function() { var c = function() {}; c.prototype = [e]; var p = new c(); return p; }(); ],
      <map(try(prototype-to-prototype(|p)))> s*
    ]

  prototype-to-prototype(|p):
        s* -> <map(prototype-to-prototype(|p))> s*
  
  prototype-to-prototype(|p):
    JSVarDecl(FSIdentifier(m), v) ->
      JSAssign(FSIdentifier(JSLFieldAccess(p, m)), "=", v)
  
  prototype-to-prototype(|p):
    JSVarDeclNoInit(i) -> []
  
  prototype-to-prototype(|p):
    JSFunctionDecl(m, x*, s*) ->
      JSExpStat(JSAssign(FSIdentifier(JSLFieldAccess(p, m)), "=", JSFunctionExp(x*, s*)))

